(in-package :dgw)

(defmethod initialize-instance :after ((self track) &key)
  (let ((process-data (autowrap:alloc '(:struct (vst3-c-api:steinberg-vst-process-data))))
        (inputs (if (zerop (.nbus-audio-in self))
                    (cffi:null-pointer)
                    (autowrap:alloc '(:struct (vst3-c-api:steinberg-vst-audio-bus-buffers))
                                    (.nbus-audio-in self))))
        (outputs (if (zerop (.nbus-audio-out self))
                     (cffi:null-pointer)
                     (autowrap:alloc '(:struct (vst3-c-api:steinberg-vst-audio-bus-buffers))
                                     (.nbus-audio-out self))))
        (buffer-in (loop repeat 2
                         collect (autowrap:calloc :float *frames-per-buffer*)))
        (buffer-out (loop repeat 2
                          collect (autowrap:calloc :float *frames-per-buffer*)))
        (event-in (make-instance 'vst3-impl::event-list)))
    (setf (.process-data self) process-data)
    (setf (.buffer-in self) buffer-in)
    (setf (.buffer-out self) buffer-out)
    (setf (.event-in self) event-in)
    
    (setf (vst3-c-api:steinberg-vst-process-data.process-mode process-data)
          vst3-c-api:+steinberg-vst-process-modes-k-realtime+)
    (setf (vst3-c-api::steinberg-vst-process-data.symbolic-sample-size process-data)
          vst3-c-api::+steinberg-vst-symbolic-sample-sizes-k-sample32+)
    (setf (vst3-c-api:steinberg-vst-process-data.num-samples process-data)
          *frames-per-buffer*)
    (setf (vst3-c-api:steinberg-vst-process-data.num-inputs process-data)
          (.nbus-audio-in self))
    (setf (vst3-c-api:steinberg-vst-process-data.num-outputs process-data)
          (.nbus-audio-out self))
    (setf (vst3-c-api:steinberg-vst-process-data.inputs process-data)
          (autowrap:ptr inputs))
    (setf (vst3-c-api:steinberg-vst-process-data.outputs process-data)
          (autowrap:ptr outputs))
    (setf (vst3-c-api:steinberg-vst-process-data.output-parameter-changes process-data)
          (cffi:null-pointer))
    (setf (vst3-c-api:steinberg-vst-process-data.input-events process-data)
          (vst3-impl::ptr (.event-in self)))
    (setf (vst3-c-api:steinberg-vst-process-data.output-events process-data)
          (cffi:null-pointer))
    (setf (vst3-c-api:steinberg-vst-process-data.process-context process-data)
          (cffi:null-pointer))          ;TODO

    (unless (zerop (.nbus-audio-in self))
      (setf (vst3-c-api::steinberg-vst-audio-bus-buffers.num-channels inputs) 2)
      (setf (vst3-c-api::steinberg-vst-audio-bus-buffers.silence-flags inputs) 0)
      (let ((channels (autowrap:alloc :pointer 2)))
        (loop for i below 2
              do (setf (autowrap:c-aref channels i :pointer)
                       (nth i (.buffer-in self))))
        (setf (vst3-c-api::steinberg-vst-audio-bus-buffers.steinberg-vst-audio-bus-buffers-channel-buffers32 inputs)
              channels)))

    (unless (zerop (.nbus-audio-out self))
      (setf (vst3-c-api::steinberg-vst-audio-bus-buffers.num-channels outputs) 2)
      (setf (vst3-c-api::steinberg-vst-audio-bus-buffers.silence-flags outputs) 0)
      (let ((channels (autowrap:alloc :pointer 2)))
        (loop for i below 2
              do (setf (autowrap:c-aref channels i :pointer)
                       (nth i (.buffer-out self))))
        (setf (vst3-c-api::steinberg-vst-audio-bus-buffers.steinberg-vst-audio-bus-buffers-channel-buffers32 outputs)
              channels)))))

(defmethod process :around ((self track))
  (let ((*process-data* (.process-data self)))
    (call-next-method)))

(defmethod process ((self master-track))
  (call-next-method))

(defmethod process ((self track))
  (loop for module in (.modules self)
        if (.start-p module)
          do (process module)))

(defmethod module-add ((self track) module)
  (setf (.modules self) (append (.modules self) (list module)))
  (initialize module)
  (start module)
  (editor-open module))

(defmethod render ((self track))
  (ig:push-id)
  (ig:button (.name self))
  (ig:pop-id))

(defmethod terminate ((self track))
  (mapc #'terminate (.tracks self))
  (mapc #'terminate (.modules self))
  
  (let* ((process-data (.process-data self))
         (inputs (vst3-c-api:steinberg-vst-process-data.inputs* process-data))
         (outputs (vst3-c-api:steinberg-vst-process-data.outputs* process-data)))
    (unless (autowrap:wrapper-null-p inputs)
      (autowrap:free
       (vst3-c-api::steinberg-vst-audio-bus-buffers.steinberg-vst-audio-bus-buffers-channel-buffers32
        inputs))
      (autowrap:free inputs))
    (mapc #'autowrap:free (.buffer-in self))
    (unless (autowrap:wrapper-null-p outputs)
      (autowrap:free
       (vst3-c-api::steinberg-vst-audio-bus-buffers.steinberg-vst-audio-bus-buffers-channel-buffers32
        outputs))
      (autowrap:free outputs))
    (mapc #'autowrap:free (.buffer-out self))
    (autowrap:free process-data)))
