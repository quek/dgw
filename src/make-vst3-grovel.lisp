(in-package :grovel)

(cffi:defctype vst3::char16 :int16)
(cffi:defctype vst3::char16_t :int16)
(cffi:defctype vst3::int32_t :int32)
(cffi:defctype vst3::uint32_t :uint32)

(defvar *vst3-c-api-h* (asdf:system-relative-pathname :dgw "lib/vst3_c_api/vst3_c_api.h"))

(defun extract-name (list)
  (let ((name (car (last list))))
    (if (consp name)
        (nth (- (length list) 2) list)
        name)))

(defun name-c (name)
  (let ((name (string name)))
    (subseq name 0 (position #\[ name))))

(defun name-lisp (name)
  (let* ((name (name-c name))
         (pos (position #\_ name :from-end t))
         (name (if pos
                   (subseq name (1+ pos))
                   name)))
    (intern (with-output-to-string (out)
       (loop for c across name
             for first = t then nil
             if (and (not first) (upper-case-p c))
               do (format out "-~c" (char-upcase c))
             else
               do (write-char (char-upcase c) out)))
            :vst3)))

(defgeneric emit (x stream)
  (:method (x stream)
    (prin1 x stream))
  (:method ((x symbol) stream)
    (when (keywordp x)
        (write-char #\: stream))
    (princ (string-downcase (symbol-name x)) stream))
  (:method ((x list) stream)
    (write-char #\( stream)
    (loop for i in x
          for space = nil then #\space
          if space
            do (write-char space stream)
          do (emit i stream))
    (write-char #\) stream)))

(defvar *h* nil)

(setf *h*
      (with-open-file (in *vst3-c-api-h*)
        (let ((*readtable* (make-readtable t nil))
              (*package* (find-package :read-vst3-c-api-h))
              (*statement* nil))
          (loop for x = (read in nil in)
                until (eq x in)
                collect x))))

(defun grovel-type (slot)
  (let* ((slot (if (string-equal "const" (car slot)) (cdr slot) slot))
         ;;(type (gethash (name-c (car slot)) *vst3-grovel-types*))
         (type (list (if (and (symbolp (cadr slot)) (string-equal "*" (cadr slot)))
                         `(:pointer ,(car slot))
                         (car slot))))
         (count (car (last slot))))
    (if (consp count)
        (append type (list :count (car count)))
        type)))

(defvar *vst3-grovel-types* (make-hash-table :test 'equal))

(defun process-typedef (out)
  (clrhash *vst3-grovel-types*)
  (labels ((map-type (xs)
             (if (endp xs)
                 nil
                 (let ((car (car xs)))
                   (cond ((string-equal "const" car)
                          (map-type (cdr xs)))
                         ((string-equal "char" car)
                          (cons :char (map-type (cdr xs))))
                         (t (cons car (map-type (cdr xs)))))))))
    (loop for typedef in *h*
          if (and (string-equal "typedef" (car typedef))
                  (string-not-equal "enum" (cadr typedef))
                  (string-not-equal "struct" (cadr typedef)))
            do (let* ((sym (extract-name typedef))
                      (name-c (name-c sym))
                      (type (map-type (cdr (if (consp (car (last typedef)))
                                               (butlast (butlast typedef))
                                               (butlast typedef)))))
                      (type `(,@type
                              ,@(let ((last (car (last typedef))))
                                  (when (consp last)
                                    `(:count ,(car last)))))))
                 (setf (gethash name-c *vst3-grovel-types*)
                       type)
                 (terpri out)
                 (emit `(ctype ,sym ,(string name-c)) out)))))

(defun process-struct-field (i)
  (let* ((name (extract-name i))
         (name-c (name-c name))
         (name-lisp (name-lisp name))
         (type  (grovel-type i)))
    `(,name-lisp ,name-c :type ,@type)))

(defun process-union (i)
  )

(defun make-vst3-gorvel ()
  (with-open-file (out (asdf:system-relative-pathname :dgw "src/XXXvst3-grovel.lisp") :direction :output :if-exists :supersede)
    (emit '(in-package :vst3) out)
    (terpri out)
    (terpri out)
    (emit `(include ,*vst3-c-api-h*) out)
    (terpri out)
    (process-typedef out)
    (terpri out)
    (loop for struct in *h*
          if (and (string-equal "struct" (car struct))
                  (consp (cddr struct)))
            do (let* ((slots (loop for i in (caddr struct)
                                   if (string-equal "union" (car i))
                                     collect (process-union i)
                                   else
                                     collect (process-struct-field i)))
                      (form `(cstruct-and-class-item ,(name-lisp (cadr struct))
                                                     ,(format nil "struct ~a" (string (cadr struct)))
                                                     ,@slots)))
                 (terpri out)
                 (pprint-logical-block (out form :prefix "(" :suffix ")")
                   (emit (pprint-pop) out)
                   (write-char #\space out)
                   (emit (pprint-pop) out)
                   (write-char #\space out)
                   (emit (pprint-pop) out)
                   (pprint-indent :block 1 out)
                   (loop (pprint-exit-if-list-exhausted)
                         (pprint-newline :mandatory out)
                         (emit (pprint-pop) out)))
                 (terpri out)))))

(make-vst3-gorvel)
